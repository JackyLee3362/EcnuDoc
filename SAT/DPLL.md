# *DPLL 算法*

------

全称为 Davis-Putnam-Logemann-Loveland（戴维斯-普特南-洛吉曼-洛夫兰德）算法，是一种完备的，基于**回溯**（backtracking）的搜索算法，用于判定命题逻辑公式（为合取范式形式）的**可满足性**，也就是求解 SAT（布尔可满足性问题）的一种（或者一类）算法。

# *SAT*（Boolean Satisfiability Problem）

------

何为布尔可满足性问题？给定一条真值表达式，包含**逻辑变量**（又称 *变量*、*命题变号*、*原子*，用小写字母 a,b,…a,b,… 表示）、**逻辑与**（AND，记为 “∧” ）运算符、**逻辑或**（OR，记为 “∨” ）运算符以及**非**（NOT，否定，记为“¬”）运算符，如：

(a∧¬b∧(¬(c∨d∨¬a)∨(b∧¬d)))∨(¬(¬(¬b∨a)∧c)∧d)(a∧¬b∧(¬(c∨d∨¬a)∨(b∧¬d)))∨(¬(¬(¬b∨a)∧c)∧d)

是否存在一组对这些变量的赋值（如把所有 a 和 d 均赋值为 True，将所有 b 和 c 赋值为 False），使得整条式子最终的运算结果为 True ？若可以，那么这个性质被称为这条逻辑公式的**可满足性**（satisfiability），如何快速高效地判断任意指定逻辑公式的可满足性是理论计算机科学中的一个重要的问题，也是第一个被证明为**NP-完全**（NP-complete，NPC）的问题。

# 暴力方案

------

对于这个问题，我们能够很容易地想到一种“暴力”的判定方法：测试这些变量赋值的每种可能的排列方式（如全部赋为 True、其一为 True其他全为 False……），若存在一种赋值排列使得公式的结果为 True，那么就可以说明这条公式是可满足的。但很显然，最坏情况下这种方法需要我们测试 2^n 种（n 为变量数）赋值排列，而用于检查每种赋值排列最终的运算结果也是不可忽略的。因此，随着公式规模的扩大，这种暴力算法所需的运算量会呈指数级飞快增长，这是我们不可接受的。

# 算法概述

------

但是根据现有计算复杂度理论，SAT问题是无法在多项式时间复杂度内解决的，DPLL算法也不例外。

DPLL算法是一种搜索算法，思想与DFS（Depth-first search，深度优先搜索）十分相似，或者说DPLL算法本身就属于DFS的范畴，其类似于上述我们设想的“暴力”算法：搜索所有可能的赋值排列。

具体地说，算法会在公式中选择一个变量（命题变号），将其赋值为 True，化简赋值后的公式，如果简化的公式是可满足的（递归地判断），那么原公式也是可满足的。否则就反过来将该变量赋值为 False，再执行一遍递归的判定，若也不能满足，那么原公式便是不可满足的。

这被称为 *分离规则* （splitting rule），因为其将原问题分离为了两个更加简单的问题。

# 概念说明

------

DPLL算法求解的是**合取范式**（Conjunctive normal form，CNF），这是指形如下式的逻辑公式：

(a∨b∨¬c)∧(¬d∨x1∨¬x2∨⋯∨x7)∧(¬r∨v∨g)∧⋯∧(a∨d∨¬d)(a∨b∨¬c)∧(¬d∨x1∨¬x2∨⋯∨x7)∧(¬r∨v∨g)∧⋯∧(a∨d∨¬d)

其由多个括号括住部分进行**逻辑与**组成，每一个括号内又是许多变量或变量的**否定**（逻辑非）的**逻辑或**组成。可以证明，所有只包含**逻辑与、逻辑或、逻辑非、逻辑蕴含和括号**的逻辑公式均可化为等价的合取范式。下面，我们称整个范式为“公式”，称每个括号里的部分为该公式的**子句**（clause），每个子句中的每个变量或其否定为**文字**（literal）。

可以看出，要使整条公式结果为 True，其所有子句都必须为 True，也就是说，每个子句中都至少有一个文字为 True，这个结论下面会用到。

DPLL 算法中的化简步骤实际上就是移除所有在赋值后值为 True的子句，以及所有在赋值后值为 False的文字。

# 化简步骤

------

这两个化简步骤是 DPLL 算法与我们“暴力”算法的主要区别，它们大大减少了搜索量，亦即加快了算法的运行速度。

- ### 第一个化简步骤：**单位子句传播**（Unit propagation）

我们称只含有一个（未赋值）变量的子句为**单位子句**（unit clause），根据上面的结论，要想让公式为 True，这个子句必须为 True，即这个变量对应的文字必须被赋值为 True。

比如下面的这条公式：

- **(a∨b∨c∨¬d)∧(¬a∨c)∧(¬c∨d)∧(a)**

其中最后一个子句就为单位子句，亦即我们要使文字 (a) 为 True。

然后，我们要依次处理这个变量在其他子句中的出现，如果另一个子句中的一个文字与单位子句中的文字相同，如上面例子中的 (a∨b∨c∨¬d)(a∨b∨c∨¬d) 子句，我们知道 (a) 的值必须为 True，所以这个子句也肯定为 True，这意味着这个子句就不会对整个公式产生额外的约束（即 b,c,d 的取值不会影响该子句的取值），我们完全可以忽略这个子句，那就删掉它吧。

再考虑上式中第二个子句，其中出现了 (a) 的否定文字，我们知道它不可能为 True了，要让这个子句的值为 True，只能寄希望于 c 的取值了，我们完全可以把 ¬a 删除（因为有没有它不影响该子句的取值）。

而第上式中第三个子句不包含 (a) 或其否定的出现，即 a 的取值不影响这个子句的取值，我们保持其不变即可。

这样，上述公式便被化简为了：

- **(c)∧(¬c∨d)∧(a)**

这个操作就被称为**单位子句传播**。

概括：**对于所有只包含一个文字 L 的子句，对于公式剩余部分中的每个子句 C：**

- **若 C 包含 L（非否定），则删除 C。**
- **若 C 包含 ¬L，则删除这个 ¬L。**

经过一次操作，我们发现公式中又出现了一个新的单位子句 (c) ，我们可以继续对其实施一遍单位子句传播，一直到整个公式中不存在任何一个单位子句对应的变量在其他子句中出现为止。

上式可被化简为：

- **(c)∧(d)∧(a)**

现在即使公式中每个子句都是单位子句，但是其分别对应的变量 c,d,a 没有在除单位子句之外的子句中出现了，单位子句传播已经没有用了，我们要实施第二个化简步骤。

- ### 第二个化简步骤：**孤立文字消去**（Pure literal elimination）

如果一个变量在整个公式中只出现了一次，那么我们可以将其进行恰当的赋值，使其所在的子句为 True。具体地说，如果其出现的那一次是以否定形式出现的，那么就将变量赋值为 False，这可使其对应文字为 True，即，使其所在子句为 True，反之则将变量赋值为 True，最终也能使其所在的子句为 True，接下来就和上述单位子句传播中发现子句为 True时的处理方式相同——删掉这个子句。

一句话概括，就为：**删除所有孤立变量所在的子句**。

对于以下的公式：

(¬r∨u)∧(r∨**c**∨¬u)∧(¬k∨r)∧(¬d∧k)

其中标红的变量 c 在整个公式中只出现了一次，我们可以将其赋值为 True使得其所在的子句 (r∨c∨¬u) 为 True，我们可以将这个子句删除。同样的，标蓝的变量 d 在整个公式中只出现了一次，且是以否定形式出现的，我们可以将其赋值为 False，使其所在子句为 True，我们也可以将其删除。由此，公式被化简为了：

(¬r∨u)∧(¬k∨r)

再来看上面的例子：

(c)∧(d)∧(a))

所有三个变量都是孤立出现的，我们可以把这三个子句全部删除，整个公式就为空了，由此我们能判断出原公式是可满足的。

以上就是这两个化简步骤。